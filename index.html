<!DOCTYPE html>


<html>
<head>
    <title>Pyodide Worker Timeout</title>
	<link rel="stylesheet" href="styles.css">
</head>
<body>
<header> </header>
<div id="container">
	<div id="level-selection-area">
	<ul>
	<li>Level 1</li>
	<li>Level 2</li>
	<li>Level 3</li>
	<li>Level 4</li>
	</ul>
	</div>

	<div id="code-area">
		<textarea id="code-input" autofocus>
move()
turnLeft()
move()
turnRight()</textarea>
		<div id="code-output"></div>
	</div>
	<div id="game-view">
		<div id="grid"></div>
	</div>
</div>
</body>

<script>


var viewState = null;
var pyodideWorker = null;

function startOrRestartPyodideWorker(){
	if (pyodideWorker) pyodideWorker.terminate()
	pyodideWorker = new Worker("worker.js");
	pyodideWorker.addEventListener("message", (event) => {
		if (event.data.type === "execution-trace"){
			initView(event.data.trace);	
		}
	});
}

function setCssProperty(prop, val){
    document.documentElement.style.setProperty(prop, val.toString())
}

startOrRestartPyodideWorker();

document.addEventListener('keydown', (event) => {
	if (event.ctrlKey && event.key === "Enter"){
		const code = document.getElementById("code-input").value;
		pyodideWorker.postMessage({ code: code});
	}
});

// We assume that the entire trace is valid
function initView(trace){
		
	viewState = {};
	viewState.trace = trace;

	const initialGameState = trace[0].level;

	viewState.nRows = initialGameState.grid.length;
	viewState.nCols = initialGameState.grid[0].length;

    viewState.grid = document.getElementById("grid");

	// Populate the grid
	viewState.grid.innerHTML = "";
	const cells = initialGameState.grid.join("")
	for (let c of cells) {
		const div = document.createElement("div")
		const isUpper = 'A' <= c && c <= 'Z'; 
		const isEmpty = c === '.';
		const classes = 
		    "game-tile "
			+ (isUpper ? " target " : "")
			+ (isEmpty ? " empty "  : c.toLowerCase());
		div.className = classes;
		viewState.grid.appendChild(div);
	}
	
	viewState.agent = document.createElement("div");
	viewState.agent.setAttribute("id", "agent");	

	viewState.grid.firstElementChild.appendChild(viewState.agent);
	
	maximizeGridSize();
	moveAgent(initialGameState.pos);
	rotateAgent(initialGameState.dir);
}

function maximizeGridSize(){
	
	const [nrows,ncols] = [viewState.nRows, viewState.nCols];

	const gridParent = viewState.grid.parentElement;
	const [width, height] = [gridParent.offsetWidth, gridParent.offsetHeight];
	const ratio = 0.95;
	viewState.cellSize = Math.min(width/ncols, height/nrows) * ratio; 

	//grid.style.gridTemplateColumns = `repeat(${ncols}, ${viewState.cellSize}px)` 
	//grid.style.gridTemplateRows    = `repeat(${nrows}, ${viewState.cellSize}px)`

	
	//viewState.agent.style.height = `${viewState.cellSize}px`;
	//viewState.agent.style.width = `${viewState.cellSize}px`;

	viewState.agent.style.height = "100%";
	viewState.agent.style.width = "100%";
}

// The agent is placed in the top left cell, so we translate it 
// to the appropriate row/col
function moveAgent(pos){
	const [row,col] = pos;
	setCssProperty("--agent-row", row);
	setCssProperty("--agent-col", col);
}

function rotateAgent(dir){
	const directions = ["img/right.png", "img/down.png", "img/left.png", "img/up.png"]
	const path = directions[dir];
	viewState.agent.style.backgroundImage = `url("${path}")`;
}

// Anticlimactic. Do something cooler later
function consumeTarget(pos){
	const [r,c] = pos;
	const nc = viewState.nCols;
	const index = nc * r + c;
	viewState.grid.children[index].classList.remove("target");
}


function gameover(win){
	console.log("Game over");
	console.log(win ? "WINNER"  : "LOSER");
}

function notifyResultOfIsColor(color, result){
	console.log(`Is current cell ${color}? ${result? "yes" : "no"}`) 

}

function highlightLineOfCode(lineno){
	console.log(`Executing line number ${lineno}`);
}	

function handleTraceMessage(msg){
	switch (msg.type) {
    case "initial-configuration":
	viewState = null;
	initView(msg.level);
	break;

	case "move": 
	moveAgent(msg.pos)
	break

	case "collected":
	consumeTarget(msg.pos);

	break;
	case "gameover":
	gameover(msg.win);
	break;
	
	case "turn":
	rotateAgent(msg.dir);
	break;
	
	case "isColor":
	notifyResultOfIsColor(msg.color, msg.result);
	break;
	
	case "lineExecuted":
	highlightLineOfCode(msg.lineno);
	break;
	}
}

function runTrace(executionTrace){
    //const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
	
	for (let msg of executionTrace){
		handleTraceMessage(msg);
	}
}

function exampleLevel(){
    const level = `        {
                 "grid": [
                         ".rgrrgbB",
                         ".....bb.",
                         "....bb..",
                         "...bb...",
                         "..bb....",
                         ".bb.....",
                         "bb......"
                 ],
                 "pos": [6,0],
                 "dir": 0
         }`

	return JSON.parse(level)
}

</script>
</html>

