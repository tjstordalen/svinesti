def get_lvl():
    return {
        "grid"     : [
                        "......bB",
                        ".....bb.",
                        "....bb..",
                        "...bb...",
                        "..bb....",
                        ".bb.....",
                        "bb......"
                    ]

        "n_rows"   : 7,
        "n_cols"   : 8,
        "bot_row"  : 0,
        "bot_col"  : 0,
       "direction" : 0,
    } 

# Brief summary
# Robuzzle is a small program designed to teach people who have never programmed
# before the basics of programming. The student controls a  robot on a grid consisting
# of colored squares. Some squares have stars on them. The goal is to write a program 
# that walks the robot over each of the stars, collecting them. We provide the functions 
# move, turnLeft, turnRight, isRed, isGreen, isBlue, and the student writes a simple
# program using these functions to collect the stars. (turnLeft/Right turns 90 degrees)
# {
#     "grid": [
#         "......bB",       r,g,b means red, green, blue tiles
#         ".....bb.",       R,G,B additionally have a star on them
#         "....bb..",       . (dot) is an "empty" tile.
#         "...bb...",       Stepping on an empty tile or leaving the
#         "..bb....",       grid loses the game.
#         ".bb.....",       Collecting all the stars wins the game.
#         "bb......"
#     ],
#     "bot_row": 6,         starting row
#     "bot_col": 0,         starting column
#     "direction": 0        0,1,2,3 = right, down, left, up 
# }

class State:
    
    # We assume the input has been checked and is valid
    def __init__(self, level):
        rows = level["level"].strip().split("\n")

        # make origo top-left instead of bottom-left
        # note that we don't need to change the 
        # starting position, as it is now correct
        rows.reverse()

        n_rows = len(rows)
        n_cols = len(rows[0])
       
        # Simply bounds checking and movement by adding a border of '#'
        padded_rows = ["#" + row + "#" for row in rows]
        new_lvl = "#" * (n_cols + 2) + "".join(padded_rows) + "#" * (n_cols + 2)
        n_cols += 2 
        n_rows += 2

        # position in the linearized grid 
        y0 = level["y0"] + 1 # we added a row above
        x0 = level["x0"] + 1 # we added a column to the left
        starting_pos = y0 * n_cols + x0
        
        dir_mapping = {"r": 0, "d": 1, "l": 2, "u": 3}
        direction = dir_mapping[level["dir"]]
        
        # We turn the level into a list so we can modify it,
        # e.g., change B to b when we collect a star
        new_lvl = list(new_lvl)

        self.n_rows  = n_rows
        self.n_cols  = n_cols
        self.grid    = new_lvl
        self.cur_pos = starting_pos
        self.cur_dir = direction

        self.UP     = self.n_cols
        self.DOWN   = -self.n_cols
        self.LEFT   = -1
        self.RIGHT  = 1
        self.n_dirs = 4
        self.directions = [self.RIGHT, self.DOWN, self.LEFT, self.UP] 

            


LOST,WON,MOVE,RIGHT,LEFT,COLOR = "lost", "won", "move", "right", "left", "color"
def update_gui(update_type, color_query = None, color_answer = None):
    
    msg = {
        "type": update_type,
        "color_query": color_query,
        "color_answer": color_answer,

        # accounting for the padding
        "bot_row" : (s.cur_pos // s.n_cols) - 1,
        "bot_col" : (s.cur_pos %  s.n_cols) - 1,
        "n_rows"  : s.n_rows - 2,
        "n_cols"  : s.n_cols - 2,
        "grid"    : "".join(s.grid).replace("#", ""),
    } 

    # todo : call the JS function
    pass

def exit_if_game_over():
    g = "".join(s.grid)
    if g[s.cur_pos] in "#.":
        update_gui(LOST)
        exit()
    if g.lower() == g:
        update_gui(WON)
        exit()

def move():
    s.cur_pos += s.directions[s.cur_dir]
    ch = s.grid[s.cur_pos]
    if ch.isupper():
        s.grid[s.cur_pos] = ch.lower()
    update_gui(MOVE)

def turnLeft():
    s.cur_dir -= 1
    s.cur_dir %= s.n_dirs 
    update_gui(LEFT)

def turnRight():
    s.cur_dir += 1
    s.cur_dir %= s.n_dirs
    update_gui(RIGHT)
 
def isColor(c):
    result = s.grid[s.cur_pos].lower() == c.lower()
    update_gui(COLOR, c, result)
    return result

def isRed():
    return isColor("r")

def isGreen():
    return isColor("g")

def isBlue():
    return isColor("b")



s = State(get_lvl())
