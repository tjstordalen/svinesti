<!DOCTYPE html>
<html>
<head>
    <title>Pyodide Worker Timeout</title>
	<link rel="stylesheet" href="styles.css">
</head>
<body>
<div id="container">

	<div id="menu-area" class="grid-item"></div>

	<div id="text-area-container" class="grid-item">

	<textarea id="pythonCode" autofocus >await test()</textarea>
	</div>
	<div id="view-container" class="grid-item">
	<!----div id="robot"> <svg class="icon"><use href="icons.svg#icon-robot"></use></svg> </div---->
	    <div id="robot"></div>
		<div id="game-grid"></div>
	</div>
	<div id="output-area" class="grid-item"></div>
</div>

<script src="./utils.js"></script>
<script>
const default_levels = load_default_levels()
const workerScriptPath = "worker.js"
console.log("Initiating new worker");
const worker = new Worker(workerScriptPath);
var currentState = null;
var currentCellSize = 0;
worker.onmessage = (event) => {
	const msg = event.data;
	
	if (msg.type == "ready") {

	}
	else if (msg.type == "execution-trace") animateExecutionTrace(JSON.parse(msg.data));
}

// Make the grid/level as large as possible while keeping each tile square
function maximizeGridSize(state){
	const grid = document.getElementById("game-grid");
	const [nrows,ncols] = [state.grid.length, state.grid[0].length];
	const [width, height] = [grid.parentElement.offsetWidth, grid.parentElement.offsetHeight];
	const ratio = 0.95;
	const cellSize = Math.min(width/ncols, height/nrows) * ratio; 
	grid.style.gridTemplateColumns = `repeat(${ncols}, ${cellSize}px)` 
	grid.style.gridTemplateRows    = `repeat(${nrows}, ${cellSize}px)`
	currentCellSize = cellSize;
}

function animateAgent(state, row, col){
	const agent = document.getElementById("robot");
	const agentToCellRatio = 1.0;
	const agentSize = currentCellSize * agentToCellRatio;
	agent.style.height = `${agentSize}px`;
	agent.style.width = `${agentSize}px`;
	
/*

	const robot = document.getElementById("robot");

	//// Size 
	const robotToCellRatio = 1.0;
	const robotSize = Math.floor(cellSize * robotToCellRatio);
	robot.style.height = `${robotSize}px`; 
	robot.style.width = `${robotSize}px`;

	//// Position
	// Get the top-left cell in the grid. This is the first one that 
	// was added above
	const origoCell = grid.firstElementChild;
	const origoCellRect = origoCell.getBoundingClientRect();

	// Here we first align the top-left corner of the robot with the top
	// left corner of the cell. Then we move the top-left corner of the 
	// bot to the center of the cell. Finally we move the center of 
	// the bot back to the center of the cell. 
	const x0 = origoCellRect.x + cellSize / 2 - robotSize / 2;
	const y0 = origoCellRect.y + cellSize / 2 - robotSize / 2;

	// Correct for actual position
	const [botRow,botCol] = state.pos;
	const botX = x0 + botCol * cellSize;
	const botY = y0 + botRow * cellSize;

	// Animate the movement. The speed and shape of the animation is in the css file
	robot.style.transform = `translate(${botX}px, ${botY}px)`;

    // Change image of Piggy depending on which direction he is traveling
	const directions = ["right", "down", "left", "up"]
*/

}
async function animateTraceMessage(msg){
    switch (msg.type){
	case "initial_configuration":
	const state = msg.data;
	currentState = state; 

    const grid = document.getElementById("game-grid");
	grid.innerHTML = "";

	// Add the cells to grid
	const cells = state.grid.join("");
	for (let c of cells) {
		const div = document.createElement("div");
        const classes = "game-tile "
					  // the regex matches a single uppercase A,B,....,Z
		              + (/^[A-Z]$/.test(c) ? "target" : " ")
					  + (c === "."  ? "empty" : " ")
					  + c.toLowerCase();
		div.className = classes;
		grid.appendChild(div);
	}

	maximizeGridSize(state);
	break;

	case "move":
	break;

	case "collected":
	break;

	case "gameover":
	break;

	case "turn":
	break;

	case "isColor":
	break;

	case "lineExecuted":
	break;
	}
}

animateTraceMessage(exampleLevel())

async function animateExecutionTrace(trace){
    for (let msg of trace){	
	
	}
}

function renderGameState(state){
	currentState = state
    const grid = document.getElementById("game-grid");

	// Clear the grid (technically, almost never necessary, but it is easy).
	grid.innerHTML = "";
	
	// Calculate the size of the game grid based on parent size
	//// leave some whitespace on each side
    const ratio = 0.9; // AT MOST 1.0 
	const marginRatio = (1.0 - ratio)/2
	const percentMargin = Math.floor(marginRatio * 100)
	grid.style.margin = `${percentMargin}%`

	//// Calculate side length for square cells
	const nrows = state.grid.length
	const ncols = state.grid[0].length
	// The grid does not have an explicit size itself, so we use the parent
	const gridRect = grid.parentNode.getBoundingClientRect();
	const maxWidth = gridRect.width * ratio / ncols;
	const maxHeight = gridRect.height * ratio / nrows;
	const cellSize = Math.floor(Math.min(maxWidth, maxHeight));

	//// Update the grid settings
	grid.style.gridTemplateColumns = `repeat(${ncols}, ${cellSize}px)`
	grid.style.gridTemplateRows    = `repeat(${nrows}, ${cellSize}px)`

	// Add cells to grid
	cells = state.grid.join("");
	for (let c of cells) {
		const div = document.createElement("div");
		let classes = "game-tile";
		if ("RGB".includes(c)) classes += " star";
		if (c === ".") classes += " empty"
		else classes += " " + c.toLowerCase();
		div.className = classes;
		grid.appendChild(div);
	}
	
	// Animate Piggy
	const robot = document.getElementById("robot");

	//// Size 
	const robotToCellRatio = 1.0;
	const robotSize = Math.floor(cellSize * robotToCellRatio);
	robot.style.height = `${robotSize}px`; 
	robot.style.width = `${robotSize}px`;

	//// Position
	// Get the top-left cell in the grid. This is the first one that 
	// was added above
	const origoCell = grid.firstElementChild;
	const origoCellRect = origoCell.getBoundingClientRect();

	// Here we first align the top-left corner of the robot with the top
	// left corner of the cell. Then we move the top-left corner of the 
	// bot to the center of the cell. Finally we move the center of 
	// the bot back to the center of the cell. 
	const x0 = origoCellRect.x + cellSize / 2 - robotSize / 2;
	const y0 = origoCellRect.y + cellSize / 2 - robotSize / 2;

	// Correct for actual position
	const [botRow,botCol] = state.pos;
	const botX = x0 + botCol * cellSize;
	const botY = y0 + botRow * cellSize;

	// Animate the movement. The speed and shape of the animation is in the css file
	robot.style.transform = `translate(${botX}px, ${botY}px)`;

    // Change image of Piggy depending on which direction he is traveling
	const directions = ["right", "down", "left", "up"]
	robot.style.backgroundImage = `url("img/${directions[state.dir]}.png")`
}


window.addEventListener("resize", (event) => maximizeGridSize(currentState));
document.addEventListener("keydown", (event) => {
  if (event.ctrlKey && event.key === "Enter") {
  		const ta = document.getElementById("pythonCode")
		const code = ta.value
		worker.postMessage({code: code});
  }
});

function exampleLevel(){
    const level = `        {
                 "grid": [
                         ".rgrrgbB",
                         ".....bb.",
                         "....bb..",
                         "...bb...",
                         "..bb....",
                         ".bb.....",
                         "bb......"
                 ],
                 "pos": [6,0],
                 "dir": 0
         }`

	return JSON.parse(`{"type": "initial_configuration", "data": ${level}}`)
}

</script>
</body>
</html>

